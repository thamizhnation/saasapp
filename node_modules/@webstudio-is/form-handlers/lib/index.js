// src/shared.ts
var formHiddenFieldPrefix = "ws--form";
var formIdFieldName = `${formHiddenFieldPrefix}-id`;
var getFormEntries = (formData) => [...formData.entries()].flatMap(
  ([key, value]) => key.startsWith(formHiddenFieldPrefix) === false && typeof value === "string" ? [[key, value]] : []
);
var getFormId = (formData) => {
  for (const [key, value] of formData.entries()) {
    if (key === formIdFieldName && typeof value === "string") {
      return value;
    }
  }
};
var getDomain = (url) => {
  try {
    return new URL(url).hostname;
  } catch {
    return;
  }
};
var formToEmail = ({
  formData,
  pageUrl,
  toEmail,
  fromEmail
}) => {
  let html = `<p>There has been a new submission of your form at <a href="${pageUrl}">${pageUrl}</a>:</p>`;
  let txt = `There has been a new submission of your form at ${pageUrl}:

`;
  html += "<table><tbody>";
  for (const [key, value] of getFormEntries(formData)) {
    html += `<tr><td><strong>${key}:</strong></td><td>${value}</td></tr>`;
    txt += `${key}: ${value}
`;
  }
  html += "</tbody></table>";
  return {
    from: fromEmail,
    to: toEmail,
    subject: `New form submission from ${getDomain(pageUrl) ?? pageUrl}`,
    txt,
    html
  };
};
var getResponseBody = async (response) => {
  const text = await response.text();
  try {
    const json = JSON.parse(text);
    return typeof json === "object" && json !== null ? { json, text } : { text };
  } catch {
    return { text: text === "" ? response.statusText : text };
  }
};
var getErrors = (json) => {
  if (json === void 0) {
    return;
  }
  if (typeof json.error === "string") {
    return [json.error];
  }
  if (typeof json.message === "string") {
    return [json.message];
  }
  if (Array.isArray(json.errors) && json.errors.every((error) => typeof error === "string")) {
    return json.errors;
  }
};

// src/mailchanels.ts
var sendEmail = async (payload) => {
  let response;
  try {
    response = await fetch("https://api.mailchannels.net/tx/v1/send", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
  } catch (error) {
    return { success: false, errors: [error.message] };
  }
  if (response.status >= 200 && response.status < 300) {
    return { success: true };
  }
  const { text, json } = await getResponseBody(response);
  return { success: false, errors: getErrors(json) ?? [text] };
};
var mailchannelsHandler = async ({
  formInfo
}) => {
  const email = formToEmail(formInfo);
  return sendEmail({
    personalizations: [{ to: [{ email: email.to }] }],
    from: { email: email.from },
    subject: email.subject,
    content: [
      { type: "text/plain", value: email.txt },
      {
        type: "text/html",
        value: `<!DOCTYPE html><html><body>${email.html}</body></html>`
      }
    ]
  });
};

// src/n8n.ts
var getAuth = (hookUrl) => {
  const url = new URL(hookUrl);
  const { username, password } = url;
  url.username = "";
  url.password = "";
  const urlWithoutAuth = url.toString();
  return {
    username,
    password,
    urlWithoutAuth
  };
};
var n8nHandler = async ({
  formInfo,
  hookUrl
}) => {
  const headers = { "Content-Type": "application/json" };
  const { username, password, urlWithoutAuth } = getAuth(hookUrl);
  if (username !== "" && password !== "") {
    headers["Authorization"] = `Basic ${btoa([username, password].join(":"))}`;
  }
  const formId = getFormId(formInfo.formData);
  if (formId === void 0) {
    return { success: false, errors: ["No form id in FormData"] };
  }
  const payload = {
    email: formToEmail(formInfo),
    // globally unique form id (can be used for unsubscribing)
    formId: [formInfo.projectId, formId].join("--"),
    action: formInfo.action,
    method: formInfo.method,
    formData: Object.fromEntries(getFormEntries(formInfo.formData))
  };
  let response;
  try {
    response = await fetch(urlWithoutAuth, {
      method: "POST",
      headers,
      body: JSON.stringify(payload)
    });
  } catch (error) {
    return { success: false, errors: [error.message] };
  }
  const { text, json } = await getResponseBody(response);
  if (response.status >= 200 && response.status < 300 && // It's difficult to control status code at n8n side.
  // Data is easier to control, so we use data to determine success.
  json?.success === true) {
    return { success: true };
  }
  return { success: false, errors: getErrors(json) ?? [text] };
};
export {
  formHiddenFieldPrefix,
  formIdFieldName,
  formToEmail,
  getFormId,
  mailchannelsHandler,
  n8nHandler
};
