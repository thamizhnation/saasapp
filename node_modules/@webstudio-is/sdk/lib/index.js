// src/schema/assets.ts
import { z } from "zod";
import { FontFormat, FontMeta } from "@webstudio-is/fonts";
var AssetId = z.string();
var baseAsset = {
  id: AssetId,
  projectId: z.string(),
  size: z.number(),
  name: z.string(),
  description: z.union([z.string(), z.null()]),
  createdAt: z.string()
};
var FontAsset = z.object({
  ...baseAsset,
  format: FontFormat,
  meta: FontMeta,
  type: z.literal("font")
});
var ImageMeta = z.object({
  width: z.number(),
  height: z.number()
});
var ImageAsset = z.object({
  ...baseAsset,
  format: z.string(),
  meta: ImageMeta,
  type: z.literal("image")
});
var Asset = z.union([FontAsset, ImageAsset]);
var Assets = z.map(AssetId, Asset);

// src/schema/pages.ts
import { z as z2 } from "zod";
var MIN_TITLE_LENGTH = 2;
var PageName = z2.string().refine((value) => value.trim() !== "", "Can't be empty");
var PageTitle = z2.string().refine(
  (val) => val.length >= MIN_TITLE_LENGTH,
  `Minimum ${MIN_TITLE_LENGTH} characters required`
);
var commonPageFields = {
  id: z2.string(),
  name: PageName,
  title: PageTitle,
  meta: z2.record(z2.string(), z2.string()),
  rootInstanceId: z2.string()
};
var HomePagePath = z2.string().refine((path) => path === "", "Home page path must be empty");
var HomePage = z2.object({
  ...commonPageFields,
  path: HomePagePath
});
var pathValidators = (baseValidator) => baseValidator.refine((path) => path !== "", "Can't be empty").refine((path) => path !== "/", "Can't be just a /").refine(
  (path) => path === "" || path.startsWith("/"),
  "Must start with a /"
).refine((path) => path.endsWith("/") === false, "Can't end with a /").refine(
  (path) => path.includes("//") === false,
  "Can't contain repeating /"
).refine(
  (path) => /^[-_a-z0-9\\/]*$/.test(path),
  "Only a-z, 0-9, -, _ and / are allowed"
).refine(
  // We use /s for our system stuff like /s/css or /s/uploads
  (path) => path !== "/s" && path.startsWith("/s/") === false,
  "/s prefix is reserved for the system"
).refine(
  // Remix serves build artefacts like JS bundles from /build
  // And we cannot customize it due to bug in Remix: https://github.com/remix-run/remix/issues/2933
  (path) => path !== "/build" && path.startsWith("/build/") === false,
  "/build prefix is reserved for the system"
);
var PagePath = pathValidators(z2.string());
var Page = z2.object({
  ...commonPageFields,
  path: PagePath
});
var Pages = z2.object({
  homePage: HomePage,
  pages: z2.array(Page).refine(
    (array) => new Set(array.map((page) => page.path)).size === array.length,
    "All paths must be unique"
  )
});

// src/schema/instances.ts
import { z as z3 } from "zod";
var Text = z3.object({
  type: z3.literal("text"),
  value: z3.string()
});
var InstanceId = z3.string();
var Id = z3.object({
  type: z3.literal("id"),
  value: InstanceId
});
var Instance = z3.object({
  type: z3.literal("instance"),
  id: InstanceId,
  component: z3.string(),
  label: z3.string().optional(),
  children: z3.array(z3.union([Id, Text]))
});
var Instances = z3.map(InstanceId, Instance);

// src/schema/data-sources.ts
import { z as z4 } from "zod";
var DataSourceId = z4.string();
var DataSourceVariableValue = z4.union([
  z4.object({
    type: z4.literal("number"),
    // initial value of variable store
    value: z4.number()
  }),
  z4.object({
    type: z4.literal("string"),
    value: z4.string()
  }),
  z4.object({
    type: z4.literal("boolean"),
    value: z4.boolean()
  }),
  z4.object({
    type: z4.literal("string[]"),
    value: z4.array(z4.string())
  })
]);
var DataSource = z4.union([
  z4.object({
    type: z4.literal("variable"),
    id: DataSourceId,
    scopeInstanceId: z4.optional(z4.string()),
    name: z4.string(),
    value: DataSourceVariableValue
  }),
  z4.object({
    type: z4.literal("expression"),
    id: DataSourceId,
    scopeInstanceId: z4.optional(z4.string()),
    name: z4.string(),
    code: z4.string()
  })
]);
var DataSources = z4.map(DataSourceId, DataSource);

// src/schema/props.ts
import { z as z5 } from "zod";
var PropId = z5.string();
var baseProp = {
  id: PropId,
  instanceId: z5.string(),
  name: z5.string(),
  required: z5.optional(z5.boolean())
};
var Prop = z5.union([
  z5.object({
    ...baseProp,
    type: z5.literal("number"),
    value: z5.number()
  }),
  z5.object({
    ...baseProp,
    type: z5.literal("string"),
    value: z5.string()
  }),
  z5.object({
    ...baseProp,
    type: z5.literal("boolean"),
    value: z5.boolean()
  }),
  z5.object({
    ...baseProp,
    type: z5.literal("asset"),
    value: z5.string()
    // asset id
  }),
  z5.object({
    ...baseProp,
    type: z5.literal("page"),
    value: z5.union([
      z5.string(),
      // page id
      z5.object({
        pageId: z5.string(),
        instanceId: z5.string()
      })
    ])
  }),
  z5.object({
    ...baseProp,
    type: z5.literal("string[]"),
    value: z5.array(z5.string())
  }),
  z5.object({
    ...baseProp,
    type: z5.literal("dataSource"),
    // data source id
    value: z5.string()
  }),
  z5.object({
    ...baseProp,
    type: z5.literal("action"),
    value: z5.array(
      z5.object({
        type: z5.literal("execute"),
        args: z5.array(z5.string()),
        code: z5.string()
      })
    )
  })
]);
var Props = z5.map(PropId, Prop);

// src/schema/breakpoints.ts
import { z as z6 } from "zod";
var BreakpointId = z6.string();
var Breakpoint = z6.object({
  id: BreakpointId,
  label: z6.string(),
  minWidth: z6.number().optional(),
  maxWidth: z6.number().optional()
}).refine(({ minWidth, maxWidth }) => {
  return (
    // Either min or max width have to be defined
    minWidth !== void 0 && maxWidth === void 0 || minWidth === void 0 && maxWidth !== void 0 || // This is a base breakpoint
    minWidth === void 0 && maxWidth === void 0
  );
}, "Either minWidth or maxWidth should be defined");
var Breakpoints = z6.map(BreakpointId, Breakpoint);
var initialBreakpoints = [
  { id: "placeholder", label: "Base" },
  { id: "placeholder", label: "Tablet", maxWidth: 991 },
  { id: "placeholder", label: "Mobile landscape", maxWidth: 767 },
  { id: "placeholder", label: "Mobile portrait", maxWidth: 479 }
];

// src/schema/style-sources.ts
import { z as z7 } from "zod";
var StyleSourceId = z7.string();
var StyleSourceToken = z7.object({
  type: z7.literal("token"),
  id: StyleSourceId,
  name: z7.string()
});
var StyleSourceLocal = z7.object({
  type: z7.literal("local"),
  id: StyleSourceId
});
var StyleSource = z7.union([StyleSourceToken, StyleSourceLocal]);
var StyleSources = z7.map(StyleSourceId, StyleSource);

// src/schema/style-source-selections.ts
import { z as z8 } from "zod";
var InstanceId2 = z8.string();
var StyleSourceId2 = z8.string();
var StyleSourceSelection = z8.object({
  instanceId: InstanceId2,
  values: z8.array(StyleSourceId2)
});
var StyleSourceSelections = z8.map(InstanceId2, StyleSourceSelection);

// src/schema/styles.ts
import { z as z9 } from "zod";
import { StyleValue } from "@webstudio-is/css-engine";
var StyleDeclRaw = z9.object({
  styleSourceId: z9.string(),
  breakpointId: z9.string(),
  state: z9.optional(z9.string()),
  // @todo can't figure out how to make property to be enum
  property: z9.string(),
  value: StyleValue
});
var StyleDecl = StyleDeclRaw;
var getStyleDeclKey = (styleDecl) => {
  return `${styleDecl.styleSourceId}:${styleDecl.breakpointId}:${styleDecl.property}:${styleDecl.state ?? ""}`;
};
var Styles = z9.map(z9.string(), StyleDecl);

// src/schema/deployment.ts
import { z as z10 } from "zod";
var Deployment = z10.object({
  domains: z10.array(z10.string()),
  projectDomain: z10.string()
});

// src/instances-utils.ts
var traverseInstances = (instances, instanceId, callback) => {
  const instance = instances.get(instanceId);
  if (instance === void 0) {
    return;
  }
  const skipTraversingChildren = callback(instance);
  if (skipTraversingChildren === false) {
    return;
  }
  for (const child of instance.children) {
    if (child.type === "id") {
      traverseInstances(instances, child.value, callback);
    }
  }
};
var findTreeInstanceIds = (instances, rootInstanceId) => {
  const ids = /* @__PURE__ */ new Set();
  traverseInstances(instances, rootInstanceId, (instance) => {
    ids.add(instance.id);
  });
  return ids;
};
var findTreeInstanceIdsExcludingSlotDescendants = (instances, rootInstanceId) => {
  const ids = /* @__PURE__ */ new Set();
  traverseInstances(instances, rootInstanceId, (instance) => {
    ids.add(instance.id);
    if (instance.component === "Slot") {
      return false;
    }
  });
  return ids;
};
var parseComponentName = (componentName) => {
  const parts = componentName.split(":");
  let namespace;
  let name;
  if (parts.length === 1) {
    [name] = parts;
  } else {
    [namespace, name] = parts;
  }
  return [namespace, name];
};

// src/scope.ts
var createScope = (occupiedIdentifiers = []) => {
  const freeIndexByPreferredName = /* @__PURE__ */ new Map();
  const scopedNameByIdMap = /* @__PURE__ */ new Map();
  for (const identifier of occupiedIdentifiers) {
    freeIndexByPreferredName.set(identifier, 1);
  }
  const getName = (id, preferredName) => {
    const cachedName = scopedNameByIdMap.get(id);
    if (cachedName !== void 0) {
      return cachedName;
    }
    const index = freeIndexByPreferredName.get(preferredName);
    freeIndexByPreferredName.set(preferredName, (index ?? 0) + 1);
    let scopedName = preferredName;
    if (index !== void 0) {
      scopedName = `${preferredName}_${index}`;
    }
    scopedNameByIdMap.set(id, scopedName);
    return scopedName;
  };
  return {
    getName
  };
};
export {
  Asset,
  Assets,
  Breakpoint,
  Breakpoints,
  DataSource,
  DataSourceVariableValue,
  DataSources,
  Deployment,
  FontAsset,
  HomePagePath,
  Id,
  ImageAsset,
  ImageMeta,
  Instance,
  Instances,
  PageName,
  PagePath,
  PageTitle,
  Pages,
  Prop,
  Props,
  StyleDecl,
  StyleSource,
  StyleSourceSelection,
  StyleSourceSelections,
  StyleSources,
  Styles,
  Text,
  createScope,
  findTreeInstanceIds,
  findTreeInstanceIdsExcludingSlotDescendants,
  getStyleDeclKey,
  initialBreakpoints,
  parseComponentName,
  pathValidators
};
