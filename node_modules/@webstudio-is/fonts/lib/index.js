// src/constants.ts
var SYSTEM_FONTS = /* @__PURE__ */ new Map([
  ["Arial", ["Roboto", "sans-serif"]],
  ["Times New Roman", ["sans"]],
  ["Courier New", ["monospace"]],
  ["system-ui", []]
]);
var DEFAULT_FONT_FALLBACK = "sans-serif";
var FONT_FORMATS = /* @__PURE__ */ new Map([
  ["woff", "woff"],
  ["woff2", "woff2"],
  ["ttf", "truetype"],
  ["otf", "opentype"]
]);
var FONT_MIME_TYPES = Array.from(FONT_FORMATS.keys()).map((format) => `.${format}`).join(", ");
var FONT_STYLES = ["normal", "italic", "oblique"];

// src/get-font-faces.ts
var formatFace = (asset, format, url) => {
  if ("variationAxes" in asset.meta) {
    const { wght, wdth } = asset.meta?.variationAxes ?? {};
    return {
      fontFamily: asset.meta.family,
      fontStyle: "normal",
      fontDisplay: "swap",
      src: `url('${url}') format('${format}')`,
      fontStretch: wdth ? `${wdth.min}% ${wdth.max}%` : void 0,
      fontWeight: wght ? `${wght.min} ${wght.max}` : void 0
    };
  }
  return {
    fontFamily: asset.meta.family,
    fontStyle: asset.meta.style,
    fontWeight: asset.meta.weight,
    fontDisplay: "swap",
    src: `url('${url}') format('${format}')`
  };
};
var getKey = (asset) => {
  if ("variationAxes" in asset.meta) {
    return asset.meta.family + Object.values(asset.meta.variationAxes).join("");
  }
  return asset.meta.family + asset.meta.style + asset.meta.weight;
};
var getFontFaces = (assets, options) => {
  const { assetBaseUrl } = options;
  const faces = /* @__PURE__ */ new Map();
  for (const asset of assets) {
    const url = `${assetBaseUrl}${asset.name}`;
    const assetKey = getKey(asset);
    const face = faces.get(assetKey);
    const format = FONT_FORMATS.get(asset.format);
    if (format === void 0) {
      continue;
    }
    if (face === void 0) {
      const face2 = formatFace(asset, format, url);
      faces.set(assetKey, face2);
      continue;
    }
    face.src += `, url('${url}') format('${format}')`;
  }
  return Array.from(faces.values());
};

// src/schema.ts
import { z } from "zod";
var FontFormat = z.union([
  z.literal("ttf"),
  z.literal("woff"),
  z.literal("woff2"),
  z.literal("otf")
]);
var AxisName = z.enum([
  "wght",
  "wdth",
  "slnt",
  "opsz",
  "ital",
  "GRAD",
  "XTRA",
  "XOPQ",
  "YOPQ",
  "YTLC",
  "YTUC",
  "YTAS",
  "YTDE",
  "YTFI"
]);
var VariationAxes = z.record(
  AxisName,
  z.object({
    name: z.string(),
    min: z.number(),
    default: z.number(),
    max: z.number()
  })
);
var FontMetaStatic = z.object({
  family: z.string(),
  style: z.enum(FONT_STYLES),
  weight: z.number()
});
var FontMetaVariable = z.object({
  family: z.string(),
  variationAxes: VariationAxes
});
var FontMeta = z.union([FontMetaStatic, FontMetaVariable]);

// src/font-weights.ts
var fontWeights = {
  "100": {
    label: "Thin",
    names: ["thin", "hairline"]
  },
  "200": {
    label: "Extra Light",
    names: ["extra light", "extralight", "ultra light", "ultralight"]
  },
  "300": {
    label: "Light",
    names: ["light"]
  },
  "400": {
    label: "Normal",
    names: ["normal", "regular"]
  },
  "500": {
    label: "Medium",
    names: ["medium"]
  },
  "600": {
    label: "Semi Bold",
    names: ["semi bold", "semibold", "demi bold", "demibold"]
  },
  "700": {
    label: "Bold",
    names: ["bold", "bold"]
  },
  "800": {
    label: "Extra Bold",
    names: ["extra bold", "extrabold", "ultra bold", "ultrabold"]
  },
  "900": {
    label: "Black",
    names: ["black", "heavy"]
  }
};
export {
  DEFAULT_FONT_FALLBACK,
  FONT_FORMATS,
  FONT_MIME_TYPES,
  FONT_STYLES,
  FontFormat,
  FontMeta,
  FontMetaStatic,
  SYSTEM_FONTS,
  fontWeights,
  getFontFaces
};
