// src/css/global-rules.ts
import { getFontFaces } from "@webstudio-is/fonts";
var addGlobalRules = (engine, { assets, assetBaseUrl }) => {
  engine.addPlaintextRule("html {margin: 0; display: grid; min-height: 100%}");
  const fontAssets = [];
  for (const asset of assets.values()) {
    if (asset.type === "font") {
      fontAssets.push(asset);
    }
  }
  const fontFaces = getFontFaces(fontAssets, { assetBaseUrl });
  for (const fontFace of fontFaces) {
    engine.addFontFaceRule(fontFace);
  }
};

// src/tree/create-elements-tree.tsx
import {
  Fragment
} from "react";

// src/context.tsx
import { createContext } from "react";
var ReactSdkContext = createContext({
  assetBaseUrl: "/",
  imageBaseUrl: "/",
  imageLoader: ({ src }) => src,
  pagesPaths: /* @__PURE__ */ new Set()
});

// src/tree/create-elements-tree.tsx
import { jsx, jsxs } from "react/jsx-runtime";
var createElementsTree = ({
  renderer,
  assetBaseUrl,
  imageBaseUrl,
  imageLoader,
  instances,
  rootInstanceId,
  Component,
  components,
  scripts
}) => {
  const rootInstance = instances.get(rootInstanceId);
  if (rootInstance === void 0) {
    return null;
  }
  const rootInstanceSelector = [rootInstanceId];
  const children = createInstanceChildrenElements({
    instances,
    instanceSelector: rootInstanceSelector,
    Component,
    children: rootInstance.children,
    components
  });
  const root = createInstanceElement({
    Component,
    instance: rootInstance,
    instanceSelector: rootInstanceSelector,
    children: [
      /* @__PURE__ */ jsxs(Fragment, { children: [
        children,
        scripts
      ] }, "children")
    ],
    components
  });
  return /* @__PURE__ */ jsx(
    ReactSdkContext.Provider,
    {
      value: {
        renderer,
        imageLoader,
        pagesPaths: /* @__PURE__ */ new Set(),
        assetBaseUrl,
        imageBaseUrl
      },
      children: root
    }
  );
};
var createInstanceChildrenElements = ({
  instances,
  instanceSelector,
  children,
  Component,
  components
}) => {
  const elements = [];
  for (const child of children) {
    if (child.type === "text") {
      elements.push(child.value);
      continue;
    }
    const childInstance = instances.get(child.value);
    if (childInstance === void 0) {
      continue;
    }
    const childInstanceSelector = [child.value, ...instanceSelector];
    const children2 = createInstanceChildrenElements({
      instances,
      instanceSelector: childInstanceSelector,
      children: childInstance.children,
      Component,
      components
    });
    const element = createInstanceElement({
      instance: childInstance,
      instanceSelector: childInstanceSelector,
      Component,
      children: children2,
      components
    });
    elements.push(element);
  }
  return elements;
};
var createInstanceElement = ({
  Component,
  instance,
  instanceSelector,
  children = [],
  components
}) => {
  return /* @__PURE__ */ jsx(
    Component,
    {
      instance,
      instanceSelector,
      components,
      children
    },
    instance.id
  );
};

// src/tree/webstudio-component.tsx
import { Fragment as Fragment2 } from "react";
import { jsx as jsx2, jsxs as jsxs2 } from "react/jsx-runtime";
var renderText = (text) => {
  const lines = text.split("\n");
  return lines.map((line, index) => /* @__PURE__ */ jsxs2(Fragment2, { children: [
    line,
    index < lines.length - 1 ? /* @__PURE__ */ jsx2("br", {}) : null
  ] }, index));
};
var renderWebstudioComponentChildren = (children) => {
  if (children === void 0 || children.length === 0) {
    return;
  }
  return children.map((child) => {
    return typeof child === "string" ? renderText(child) : child;
  });
};
var idAttribute = "data-ws-id";
var selectorIdAttribute = "data-ws-selector";
var componentAttribute = "data-ws-component";
var showAttribute = "data-ws-show";
var indexAttribute = "data-ws-index";
var collapsedAttribute = "data-ws-collapsed";

// src/css/style-rules.ts
var getStyleRules = (styles, styleSourceSelections) => {
  if (styles === void 0 || styleSourceSelections === void 0) {
    return [];
  }
  const stylesByStyleSourceId = /* @__PURE__ */ new Map();
  for (const styleDecl of styles.values()) {
    const { styleSourceId } = styleDecl;
    let styleSourceStyles = stylesByStyleSourceId.get(styleSourceId);
    if (styleSourceStyles === void 0) {
      styleSourceStyles = [];
      stylesByStyleSourceId.set(styleSourceId, styleSourceStyles);
    }
    styleSourceStyles.push(styleDecl);
  }
  const styleRules = [];
  for (const { instanceId, values } of styleSourceSelections.values()) {
    const styleRuleByBreakpointId = /* @__PURE__ */ new Map();
    for (const styleSourceId of values) {
      const styleSourceStyles = stylesByStyleSourceId.get(styleSourceId);
      if (styleSourceStyles === void 0) {
        continue;
      }
      for (const {
        breakpointId,
        state,
        property,
        value
      } of styleSourceStyles) {
        const key = `${breakpointId}:${state ?? ""}`;
        let styleRule = styleRuleByBreakpointId.get(key);
        if (styleRule === void 0) {
          styleRule = {
            instanceId,
            breakpointId,
            state,
            style: {}
          };
          styleRuleByBreakpointId.set(key, styleRule);
        }
        styleRule.style[property] = value;
      }
    }
    styleRules.push(...styleRuleByBreakpointId.values());
  }
  return styleRules;
};
var getPresetStyleRules = (component, presetStyle) => {
  const presetStyleRules = /* @__PURE__ */ new Map();
  for (const [tag, styles] of Object.entries(presetStyle)) {
    for (const styleDecl of styles) {
      const selector = `${tag}:where([${componentAttribute}="${component}"])${styleDecl.state ?? ""}`;
      let rule = presetStyleRules.get(selector);
      if (rule === void 0) {
        rule = {};
        presetStyleRules.set(selector, rule);
      }
      rule[styleDecl.property] = styleDecl.value;
    }
  }
  return presetStyleRules;
};

// src/css/css.ts
import { createCssEngine } from "@webstudio-is/css-engine";
var createImageValueTransformer = (assets, options) => (styleValue) => {
  if (styleValue.type === "image" && styleValue.value.type === "asset") {
    const asset = assets.get(styleValue.value.value);
    if (asset === void 0) {
      return { type: "keyword", value: "none" };
    }
    const { assetBaseUrl } = options;
    const url = `${assetBaseUrl}${asset.name}`;
    return {
      type: "image",
      value: {
        type: "url",
        url
      },
      hidden: styleValue.hidden
    };
  }
};
var generateCssText = (data, options) => {
  const assets = new Map(data.assets.map((asset) => [asset.id, asset]));
  const breakpoints = new Map(data.breakpoints);
  const styles = new Map(data.styles);
  const styleSourceSelections = new Map(data.styleSourceSelections);
  const engine = createCssEngine({ name: "ssr" });
  addGlobalRules(engine, {
    assets,
    assetBaseUrl: options.assetBaseUrl
  });
  for (const breakpoint of breakpoints.values()) {
    engine.addMediaRule(breakpoint.id, breakpoint);
  }
  for (const [component, meta] of data.componentMetas) {
    const presetStyle = meta.presetStyle;
    if (presetStyle === void 0) {
      continue;
    }
    const rules = getPresetStyleRules(component, presetStyle);
    for (const [selector, style] of rules) {
      engine.addStyleRule(selector, { style });
    }
  }
  const styleRules = getStyleRules(styles, styleSourceSelections);
  for (const { breakpointId, instanceId, state, style } of styleRules) {
    engine.addStyleRule(
      `[${idAttribute}="${instanceId}"]${state ?? ""}`,
      {
        breakpoint: breakpointId,
        style
      },
      createImageValueTransformer(assets, options)
    );
  }
  return engine.cssText;
};

// src/app/root.tsx
import { Links, Meta, Outlet as DefaultOutlet } from "@remix-run/react";
import { jsx as jsx3, jsxs as jsxs3 } from "react/jsx-runtime";
var Root = ({
  Outlet = DefaultOutlet
}) => {
  return /* @__PURE__ */ jsxs3("html", { lang: "en", children: [
    /* @__PURE__ */ jsxs3("head", { children: [
      /* @__PURE__ */ jsx3("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ jsx3("meta", { name: "viewport", content: "width=device-width,initial-scale=1" }),
      /* @__PURE__ */ jsx3("link", { rel: "icon", href: "/favicon.ico", type: "image/x-icon" }),
      /* @__PURE__ */ jsx3("link", { rel: "shortcut icon", href: "/favicon.ico", type: "image/x-icon" }),
      /* @__PURE__ */ jsx3(Meta, {}),
      /* @__PURE__ */ jsx3(Links, {})
    ] }),
    /* @__PURE__ */ jsx3(Outlet, {})
  ] });
};

// src/prop-meta.ts
import { z } from "zod";
var common = {
  label: z.string().optional(),
  description: z.string().optional(),
  required: z.boolean()
};
var Number = z.object({
  ...common,
  control: z.literal("number"),
  type: z.literal("number"),
  defaultValue: z.number().optional()
});
var Range = z.object({
  ...common,
  control: z.literal("range"),
  type: z.literal("number"),
  defaultValue: z.number().optional()
});
var Text = z.object({
  ...common,
  control: z.literal("text"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  /**
   * The number of rows in <textarea>. If set to 0 an <input> will be used instead.
   * In line with Storybook team's plan: https://github.com/storybookjs/storybook/issues/21100
   */
  rows: z.number().optional()
});
var Code = z.object({
  ...common,
  control: z.literal("code"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  /**
   * The number of rows in <textarea>. If set to 0 an <input> will be used instead.
   * In line with Storybook team's plan: https://github.com/storybookjs/storybook/issues/21100
   */
  rows: z.number().optional()
});
var Color = z.object({
  ...common,
  control: z.literal("color"),
  type: z.literal("string"),
  defaultValue: z.string().optional()
});
var Boolean = z.object({
  ...common,
  control: z.literal("boolean"),
  type: z.literal("boolean"),
  defaultValue: z.boolean().optional()
});
var Radio = z.object({
  ...common,
  control: z.literal("radio"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  options: z.array(z.string())
});
var InlineRadio = z.object({
  ...common,
  control: z.literal("inline-radio"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  options: z.array(z.string())
});
var Select = z.object({
  ...common,
  control: z.literal("select"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  options: z.array(z.string())
});
var Check = z.object({
  ...common,
  control: z.literal("check"),
  type: z.literal("string[]"),
  defaultValue: z.array(z.string()).optional(),
  options: z.array(z.string())
});
var InlineCheck = z.object({
  ...common,
  control: z.literal("inline-check"),
  type: z.literal("string[]"),
  defaultValue: z.array(z.string()).optional(),
  options: z.array(z.string())
});
var MultiSelect = z.object({
  ...common,
  control: z.literal("multi-select"),
  type: z.literal("string[]"),
  defaultValue: z.array(z.string()).optional(),
  options: z.array(z.string())
});
var File = z.object({
  ...common,
  control: z.literal("file"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  /** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept */
  accept: z.string().optional()
});
var Url = z.object({
  ...common,
  control: z.literal("url"),
  type: z.literal("string"),
  defaultValue: z.string().optional()
});
var ObjectType = z.object({
  ...common,
  control: z.literal("object"),
  // @todo not sure what type should be here
  // (we don't support Object yet, added for completeness)
  type: z.literal("Record<string, string>"),
  defaultValue: z.record(z.string()).optional()
});
var Date = z.object({
  ...common,
  control: z.literal("date"),
  // @todo not sure what type should be here
  // (we don't support Date yet, added for completeness)
  type: z.literal("string"),
  defaultValue: z.string().optional()
});
var Action = z.object({
  ...common,
  control: z.literal("action"),
  type: z.literal("action"),
  defaultValue: z.undefined().optional()
});
var PropMeta = z.union([
  Number,
  Range,
  Text,
  Code,
  Color,
  Boolean,
  Radio,
  InlineRadio,
  Select,
  MultiSelect,
  Check,
  InlineCheck,
  File,
  Url,
  ObjectType,
  Date,
  Action
]);

// src/components/component-meta.ts
import { z as z3 } from "zod";

// src/embed-template.ts
import { z as z2 } from "zod";
import { nanoid } from "nanoid";
import { titleCase } from "title-case";
import { noCase } from "no-case";
import { StyleValue } from "@webstudio-is/css-engine";

// src/expression.ts
import jsep from "jsep";
import jsepAssignment from "@jsep-plugin/assignment";
jsep.plugins.register(jsepAssignment);
var generateCode = (node, failOnForbidden, effectful, transformIdentifier) => {
  if (node.type === "Identifier") {
    return transformIdentifier(node.name, false);
  }
  if (node.type === "MemberExpression") {
    if (failOnForbidden) {
      const object2 = generateCode(
        node.object,
        false,
        effectful,
        transformIdentifier
      );
      const property2 = generateCode(
        node.property,
        false,
        effectful,
        transformIdentifier
      );
      throw Error(`Cannot access "${property2}" of "${object2}"`);
    }
    const object = generateCode(
      node.object,
      failOnForbidden,
      effectful,
      transformIdentifier
    );
    const property = generateCode(
      node.property,
      failOnForbidden,
      effectful,
      transformIdentifier
    );
    return `${object}.${property}`;
  }
  if (node.type === "Literal") {
    return node.raw;
  }
  if (node.type === "UnaryExpression") {
    const arg = generateCode(
      node.argument,
      failOnForbidden,
      effectful,
      transformIdentifier
    );
    return `${node.operator}${arg}`;
  }
  if (node.type === "BinaryExpression") {
    const left = generateCode(
      node.left,
      failOnForbidden,
      effectful,
      transformIdentifier
    );
    const right = generateCode(
      node.right,
      failOnForbidden,
      effectful,
      transformIdentifier
    );
    return `${left} ${node.operator} ${right}`;
  }
  if (node.type === "ArrayExpression") {
    const elements = node.elements.map(
      (element) => generateCode(
        element,
        failOnForbidden,
        effectful,
        transformIdentifier
      )
    );
    return `[${elements.join(", ")}]`;
  }
  if (node.type === "CallExpression") {
    if (failOnForbidden) {
      const callee2 = generateCode(
        node.callee,
        false,
        effectful,
        transformIdentifier
      );
      throw Error(`Cannot call "${callee2}"`);
    }
    const callee = generateCode(
      node.callee,
      failOnForbidden,
      effectful,
      transformIdentifier
    );
    const args = node.arguments.map(
      (arg) => generateCode(arg, failOnForbidden, effectful, transformIdentifier)
    );
    return `${callee}(${args.join(", ")})`;
  }
  if (node.type === "ThisExpression") {
    if (failOnForbidden) {
      throw Error(`"this" is not supported`);
    }
    return "this";
  }
  if (node.type === "ConditionalExpression") {
    throw Error("Ternary operator is not supported");
  }
  if (node.type === "Compound") {
    throw Error("Cannot use multiple expressions");
  }
  if (node.type === "AssignmentExpression") {
    if (node.operator !== "=") {
      throw Error(`Only "=" assignment operator is supported`);
    }
    if (effectful === false) {
      throw Error(`Cannot use assignment in this expression`);
    }
    const left = generateCode(
      node.left,
      failOnForbidden,
      effectful,
      // override and mark all identifiers inside of left expression as assignee
      (id) => transformIdentifier(id, true)
    );
    const right = generateCode(
      node.right,
      failOnForbidden,
      effectful,
      transformIdentifier
    );
    return `${left} ${node.operator} ${right}`;
  }
  if (node.type === "UpdateExpression") {
    throw Error(`"${node.operator}" operator is not supported`);
  }
  node;
  return "";
};
var validateExpression = (code, options) => {
  const { effectful = false, transformIdentifier = (id) => id } = options ?? {};
  const expression = jsep(code);
  return generateCode(expression, true, effectful, transformIdentifier);
};
var sortTopologically = (list, depsById, explored = /* @__PURE__ */ new Set(), sorted = []) => {
  for (const id of list) {
    if (explored.has(id)) {
      continue;
    }
    explored.add(id);
    const deps = depsById.get(id);
    if (deps) {
      sortTopologically(deps, depsById, explored, sorted);
    }
    sorted.push(id);
  }
  return sorted;
};
var computeExpressionDependencies = (expressions, expressionId, dependencies) => {
  const depsById = dependencies.get(expressionId);
  if (depsById) {
    return depsById;
  }
  const parentDeps = /* @__PURE__ */ new Set();
  const code = expressions.get(expressionId);
  if (code === void 0) {
    return parentDeps;
  }
  dependencies.set(expressionId, parentDeps);
  validateExpression(code, {
    transformIdentifier: (id) => {
      parentDeps.add(id);
      const childDeps = computeExpressionDependencies(
        expressions,
        id,
        dependencies
      );
      for (const depId of childDeps) {
        parentDeps.add(depId);
      }
      return id;
    }
  });
  return parentDeps;
};
var computeExpressionsDependencies = (expressions) => {
  const dependencies = /* @__PURE__ */ new Map();
  for (const id of expressions.keys()) {
    computeExpressionDependencies(expressions, id, dependencies);
  }
  return dependencies;
};
var dataSourceVariablePrefix = "$ws$dataSource$";
var encodeDataSourceVariable = (id) => {
  const encoded = id.replaceAll("-", "__DASH__");
  return `${dataSourceVariablePrefix}${encoded}`;
};
var decodeDataSourceVariable = (name) => {
  if (name.startsWith(dataSourceVariablePrefix)) {
    const encoded = name.slice(dataSourceVariablePrefix.length);
    return encoded.replaceAll("__DASH__", "-");
  }
  return;
};
var generateDataSources = ({
  scope,
  typed = false,
  dataSources,
  props
}) => {
  const variables = /* @__PURE__ */ new Map();
  let body = "";
  const output = /* @__PURE__ */ new Map();
  const depsById = /* @__PURE__ */ new Map();
  const codeById = /* @__PURE__ */ new Map();
  for (const dataSource of dataSources.values()) {
    if (dataSource.type === "expression") {
      const deps = /* @__PURE__ */ new Set();
      const newCode = validateExpression(dataSource.code, {
        transformIdentifier: (identifier) => {
          const depId = decodeDataSourceVariable(identifier);
          const dep = depId ? dataSources.get(depId) : void 0;
          if (dep) {
            deps.add(dep.id);
            return scope.getName(dep.id, dep.name);
          }
          console.error(`Unknown dependency "${identifier}"`);
          return identifier;
        }
      });
      depsById.set(dataSource.id, deps);
      codeById.set(dataSource.id, newCode);
    }
  }
  const sortedDataSources = sortTopologically(
    new Set(dataSources.keys()),
    depsById
  );
  for (const dataSourceId of sortedDataSources) {
    const dataSource = dataSources.get(dataSourceId);
    if (dataSource?.type === "variable") {
      const valueName = scope.getName(dataSource.id, dataSource.name);
      const setterName = scope.getName(
        `set$${dataSource.id}`,
        `set$${dataSource.name}`
      );
      const initialValue = dataSource.value.value;
      output.set(dataSource.id, valueName);
      variables.set(dataSource.id, { valueName, setterName, initialValue });
    }
    if (dataSource?.type === "expression") {
      const name = scope.getName(dataSource.id, dataSource.name);
      const code = codeById.get(dataSourceId);
      output.set(dataSource.id, name);
      body += `let ${name} = (${code});
`;
    }
  }
  for (const prop of props.values()) {
    if (prop.type !== "action") {
      continue;
    }
    const name = scope.getName(prop.id, prop.name);
    output.set(prop.id, name);
    const setters = /* @__PURE__ */ new Set();
    let args = void 0;
    let newCode = "";
    for (const value of prop.value) {
      args = value.args;
      newCode += validateExpression(value.code, {
        effectful: true,
        transformIdentifier: (identifier, assignee) => {
          if (args?.includes(identifier)) {
            return identifier;
          }
          const depId = decodeDataSourceVariable(identifier);
          const dep = depId ? dataSources.get(depId) : void 0;
          if (dep) {
            const name2 = scope.getName(dep.id, dep.name);
            if (assignee) {
              setters.add(dep.id);
            }
            return name2;
          }
          console.error(`Unknown dependency "${identifier}"`);
          return identifier;
        }
      });
      newCode += `
`;
    }
    if (args === void 0) {
      continue;
    }
    if (typed) {
      args = args.map((arg) => `${arg}: any`);
    }
    body += `let ${name} = (${args.join(", ")}) => {
`;
    body += newCode;
    for (const dataSourceId of setters.values()) {
      const variable = variables.get(dataSourceId);
      if (variable) {
        body += `${variable.setterName}(${variable.valueName})
`;
      }
    }
    body += `}
`;
  }
  return {
    variables,
    body,
    output
  };
};

// src/embed-template.ts
var EmbedTemplateText = z2.object({
  type: z2.literal("text"),
  value: z2.string()
});
var EmbedTemplateDataSource = z2.union([
  z2.object({
    type: z2.literal("variable"),
    initialValue: z2.union([
      z2.string(),
      z2.number(),
      z2.boolean(),
      z2.array(z2.string())
    ])
  }),
  z2.object({
    type: z2.literal("expression"),
    code: z2.string()
  })
]);
var EmbedTemplateProp = z2.union([
  z2.object({
    type: z2.literal("dataSource"),
    name: z2.string(),
    dataSourceName: z2.string()
  }),
  z2.object({
    type: z2.literal("number"),
    name: z2.string(),
    value: z2.number()
  }),
  z2.object({
    type: z2.literal("string"),
    name: z2.string(),
    value: z2.string()
  }),
  z2.object({
    type: z2.literal("boolean"),
    name: z2.string(),
    value: z2.boolean()
  }),
  z2.object({
    type: z2.literal("string[]"),
    name: z2.string(),
    value: z2.array(z2.string())
  }),
  z2.object({
    type: z2.literal("action"),
    name: z2.string(),
    value: z2.array(
      z2.object({
        type: z2.literal("execute"),
        args: z2.optional(z2.array(z2.string())),
        code: z2.string()
      })
    )
  })
]);
var EmbedTemplateStyleDeclRaw = z2.object({
  // State selector, e.g. :hover
  state: z2.optional(z2.string()),
  property: z2.string(),
  value: StyleValue
});
var EmbedTemplateStyleDecl = EmbedTemplateStyleDeclRaw;
var EmbedTemplateInstance = z2.lazy(
  () => z2.object({
    type: z2.literal("instance"),
    component: z2.string(),
    label: z2.optional(z2.string()),
    dataSources: z2.optional(z2.record(z2.string(), EmbedTemplateDataSource)),
    props: z2.optional(z2.array(EmbedTemplateProp)),
    tokens: z2.optional(z2.array(z2.string())),
    styles: z2.optional(z2.array(EmbedTemplateStyleDecl)),
    children: WsEmbedTemplate
  })
);
var WsEmbedTemplate = z2.lazy(
  () => z2.array(z2.union([EmbedTemplateInstance, EmbedTemplateText]))
);
var getDataSourceValue = (value) => {
  if (typeof value === "string") {
    return { type: "string", value };
  }
  if (typeof value === "number") {
    return { type: "number", value };
  }
  if (typeof value === "boolean") {
    return { type: "boolean", value };
  }
  if (Array.isArray(value)) {
    return { type: "string[]", value };
  }
  value;
  throw Error("Impossible case");
};
var createInstancesFromTemplate = (treeTemplate, instances, props, dataSourceByRef, styleSourceSelections, styleSources, styles, metas, defaultBreakpointId, generateId) => {
  const parentChildren = [];
  for (const item of treeTemplate) {
    if (item.type === "instance") {
      const instanceId = generateId();
      if (item.dataSources) {
        for (const [name, dataSource] of Object.entries(item.dataSources)) {
          if (dataSourceByRef.has(name)) {
            throw Error(`${name} data source already defined`);
          }
          if (dataSource.type === "variable") {
            dataSourceByRef.set(name, {
              type: "variable",
              id: generateId(),
              scopeInstanceId: instanceId,
              name,
              value: getDataSourceValue(dataSource.initialValue)
            });
          }
          if (dataSource.type === "expression") {
            dataSourceByRef.set(name, {
              type: "expression",
              id: generateId(),
              scopeInstanceId: instanceId,
              name,
              // replace all references with variable names
              code: validateExpression(dataSource.code, {
                transformIdentifier: (ref) => {
                  const id = dataSourceByRef.get(ref)?.id ?? ref;
                  return encodeDataSourceVariable(id);
                }
              })
            });
          }
        }
      }
      if (item.props) {
        for (const prop of item.props) {
          const propId = generateId();
          if (prop.type === "action") {
            props.push({
              id: propId,
              instanceId,
              type: "action",
              name: prop.name,
              value: prop.value.map((value) => {
                const args = value.args ?? [];
                return {
                  type: "execute",
                  args,
                  // replace all references with variable names
                  code: validateExpression(value.code, {
                    effectful: true,
                    transformIdentifier: (ref) => {
                      if (args.includes(ref)) {
                        return ref;
                      }
                      const id = dataSourceByRef.get(ref)?.id ?? ref;
                      return encodeDataSourceVariable(id);
                    }
                  })
                };
              })
            });
            continue;
          }
          if (prop.type === "dataSource") {
            const dataSource = dataSourceByRef.get(prop.dataSourceName);
            if (dataSource === void 0) {
              throw Error(`${prop.dataSourceName} data source is not defined`);
            }
            props.push({
              id: propId,
              instanceId,
              type: "dataSource",
              name: prop.name,
              value: dataSource.id
            });
            continue;
          }
          props.push({ id: propId, instanceId, ...prop });
        }
      }
      const styleSourceIds = [];
      if (item.tokens) {
        const meta = metas.get(item.component);
        if (meta?.presetTokens) {
          for (const name of item.tokens) {
            const tokenValue = meta.presetTokens[name];
            if (tokenValue) {
              const styleSourceId = `${item.component}:${name}`;
              styleSourceIds.push(styleSourceId);
              styleSources.push({
                type: "token",
                id: styleSourceId,
                name: titleCase(noCase(name))
              });
              for (const styleDecl of tokenValue.styles) {
                styles.push({
                  breakpointId: defaultBreakpointId,
                  styleSourceId,
                  state: styleDecl.state,
                  property: styleDecl.property,
                  value: styleDecl.value
                });
              }
            }
          }
        }
      }
      if (item.styles) {
        const styleSourceId = generateId();
        styleSources.push({
          type: "local",
          id: styleSourceId
        });
        styleSourceIds.push(styleSourceId);
        for (const styleDecl of item.styles) {
          styles.push({
            breakpointId: defaultBreakpointId,
            styleSourceId,
            state: styleDecl.state,
            property: styleDecl.property,
            value: styleDecl.value
          });
        }
      }
      if (styleSourceIds.length > 0) {
        styleSourceSelections.push({
          instanceId,
          values: styleSourceIds
        });
      }
      const instance = {
        type: "instance",
        id: instanceId,
        label: item.label,
        component: item.component,
        children: []
      };
      instances.push(instance);
      instance.children = createInstancesFromTemplate(
        item.children,
        instances,
        props,
        dataSourceByRef,
        styleSourceSelections,
        styleSources,
        styles,
        metas,
        defaultBreakpointId,
        generateId
      );
      parentChildren.push({
        type: "id",
        value: instanceId
      });
    }
    if (item.type === "text") {
      parentChildren.push({
        type: "text",
        value: item.value
      });
    }
  }
  return parentChildren;
};
var generateDataFromEmbedTemplate = (treeTemplate, metas, defaultBreakpointId, generateId = nanoid) => {
  const instances = [];
  const props = [];
  const dataSourceByRef = /* @__PURE__ */ new Map();
  const styleSourceSelections = [];
  const styleSources = [];
  const styles = [];
  const children = createInstancesFromTemplate(
    treeTemplate,
    instances,
    props,
    dataSourceByRef,
    styleSourceSelections,
    styleSources,
    styles,
    metas,
    defaultBreakpointId,
    generateId
  );
  return {
    children,
    instances,
    props,
    dataSources: Array.from(dataSourceByRef.values()),
    styleSourceSelections,
    styleSources,
    styles
  };
};
var namespaceEmbedTemplateComponents = (template, namespace, components) => {
  return template.map((item) => {
    if (item.type === "text") {
      return item;
    }
    if (item.type === "instance") {
      const prefix = components.has(item.component) ? `${namespace}:` : "";
      return {
        ...item,
        component: `${prefix}${item.component}`,
        children: namespaceEmbedTemplateComponents(
          item.children,
          namespace,
          components
        )
      };
    }
    item;
    throw Error("Impossible case");
  });
};
var namespaceMeta = (meta, namespace, components) => {
  const newMeta = { ...meta };
  if (newMeta.requiredAncestors) {
    newMeta.requiredAncestors = newMeta.requiredAncestors.map(
      (component) => components.has(component) ? `${namespace}:${component}` : component
    );
  }
  if (newMeta.invalidAncestors) {
    newMeta.invalidAncestors = newMeta.invalidAncestors.map(
      (component) => components.has(component) ? `${namespace}:${component}` : component
    );
  }
  if (newMeta.indexWithinAncestor) {
    newMeta.indexWithinAncestor = components.has(newMeta.indexWithinAncestor) ? `${namespace}:${newMeta.indexWithinAncestor}` : newMeta.indexWithinAncestor;
  }
  if (newMeta.template) {
    newMeta.template = namespaceEmbedTemplateComponents(
      newMeta.template,
      namespace,
      components
    );
  }
  return newMeta;
};

// src/components/component-meta.ts
var WsComponentPropsMeta = z3.object({
  props: z3.record(PropMeta),
  // Props that will be always visible in properties panel.
  initialProps: z3.array(z3.string()).optional()
});
var componentCategories = [
  "general",
  "text",
  "media",
  "forms",
  "radix",
  "hidden"
];
var stateCategories = ["states", "component-states"];
var ComponentState = z3.object({
  category: z3.enum(stateCategories).optional(),
  selector: z3.string(),
  label: z3.string()
});
var ComponentToken = z3.object({
  variant: z3.optional(z3.string()),
  styles: z3.array(EmbedTemplateStyleDecl)
});
var defaultStates = [
  { selector: ":hover", label: "Hover" },
  { selector: ":active", label: "Active" },
  { selector: ":focus", label: "Focus" },
  { selector: ":focus-visible", label: "Focus Visible" },
  { selector: ":focus-within", label: "Focus Within" }
];
var WsComponentMeta = z3.object({
  category: z3.enum(componentCategories).optional(),
  // container - can accept other components with dnd or be edited as text
  // control - usually form controls like inputs, without children
  // embed - images, videos or other embeddable components, without children
  // rich-text-child - formatted text fragment, not listed in components list
  type: z3.enum(["container", "control", "embed", "rich-text-child"]),
  requiredAncestors: z3.optional(z3.array(z3.string())),
  invalidAncestors: z3.optional(z3.array(z3.string())),
  // when this field is specified component receives
  // prop with index of same components withiin specified ancestor
  // important to automatically enumerate collections without
  // naming every item manually
  indexWithinAncestor: z3.optional(z3.string()),
  stylable: z3.optional(z3.boolean()),
  // specifies whether the instance can be deleted,
  // copied or dragged out of its parent instance
  // true by default
  detachable: z3.optional(z3.boolean()),
  label: z3.optional(z3.string()),
  description: z3.string().optional(),
  icon: z3.string(),
  presetStyle: z3.optional(
    z3.record(z3.string(), z3.array(EmbedTemplateStyleDecl))
  ),
  presetTokens: z3.optional(z3.record(z3.string(), ComponentToken)),
  states: z3.optional(z3.array(ComponentState)),
  template: z3.optional(WsEmbedTemplate),
  order: z3.number().optional()
});

// src/props.ts
var normalizeProps = ({
  props,
  assetBaseUrl,
  assets,
  pages
}) => {
  const newProps = [];
  for (const prop of props) {
    if (prop.type === "asset") {
      const assetId = prop.value;
      const asset = assets.get(assetId);
      if (asset === void 0) {
        continue;
      }
      newProps.push({
        id: prop.id,
        name: prop.name,
        required: prop.required,
        instanceId: prop.instanceId,
        type: "string",
        value: `${assetBaseUrl}${asset.name}`
      });
      continue;
    }
    if (prop.type === "page") {
      let page;
      let idProp;
      if (typeof prop.value === "string") {
        const pageId = prop.value;
        page = pages.get(pageId);
      } else {
        const { pageId, instanceId } = prop.value;
        page = pages.get(pageId);
        idProp = props.find(
          (prop2) => prop2.instanceId === instanceId && prop2.name === "id"
        );
      }
      if (page === void 0) {
        continue;
      }
      const url = new URL(page.path, "https://any-valid.url");
      let value = url.pathname;
      if (idProp?.type === "string") {
        const hash = idProp.value;
        url.hash = encodeURIComponent(hash);
        value = `${url.pathname}${url.hash}`;
      }
      newProps.push({
        id: prop.id,
        name: prop.name,
        required: prop.required,
        instanceId: prop.instanceId,
        type: "string",
        value
      });
      continue;
    }
    newProps.push(prop);
  }
  return newProps;
};
var getPropsByInstanceId = (props) => {
  const propsByInstanceId = /* @__PURE__ */ new Map();
  for (const prop of props.values()) {
    let instanceProps = propsByInstanceId.get(prop.instanceId);
    if (instanceProps === void 0) {
      instanceProps = [];
      propsByInstanceId.set(prop.instanceId, instanceProps);
    }
    instanceProps.push(prop);
  }
  return propsByInstanceId;
};
var getInstanceIdFromComponentProps = (props) => {
  return props[idAttribute];
};
var getIndexWithinAncestorFromComponentProps = (props) => {
  return props[indexAttribute];
};

// src/instance-utils.ts
var getIndexesWithinAncestors = (metas, instances, rootIds) => {
  const ancestors = /* @__PURE__ */ new Set();
  for (const meta of metas.values()) {
    if (meta.indexWithinAncestor !== void 0) {
      ancestors.add(meta.indexWithinAncestor);
    }
  }
  const indexes = /* @__PURE__ */ new Map();
  const traverseInstances = (instances2, instanceId, latestIndexes2 = /* @__PURE__ */ new Map()) => {
    const instance = instances2.get(instanceId);
    if (instance === void 0) {
      return;
    }
    const meta = metas.get(instance.component);
    if (meta === void 0) {
      return;
    }
    if (ancestors.has(instance.component)) {
      latestIndexes2 = new Map(latestIndexes2);
      latestIndexes2.set(instance.component, /* @__PURE__ */ new Map());
    }
    if (meta.indexWithinAncestor !== void 0) {
      const ancestorIndexes = latestIndexes2.get(meta.indexWithinAncestor);
      if (ancestorIndexes !== void 0) {
        let index = ancestorIndexes.get(instance.component) ?? -1;
        index += 1;
        ancestorIndexes.set(instance.component, index);
        indexes.set(instance.id, index);
      }
    }
    for (const child of instance.children) {
      if (child.type === "id") {
        traverseInstances(instances2, child.value, latestIndexes2);
      }
    }
  };
  const latestIndexes = /* @__PURE__ */ new Map();
  for (const instanceId of rootIds) {
    traverseInstances(instances, instanceId, latestIndexes);
  }
  return indexes;
};

// src/hook.ts
var getClosestInstance = (instancePath, currentInstance, closestComponent) => {
  let matched = false;
  for (const instance of instancePath) {
    if (currentInstance === instance) {
      matched = true;
    }
    if (matched && instance.component === closestComponent) {
      return instance;
    }
  }
};

// src/generator.ts
var generateUtilsExport = (siteData) => {
  const pagesPaths = [siteData.pages.homePage.path];
  for (const page of siteData.pages.pages) {
    pagesPaths.push(page.path);
  }
  const generatedPagesPaths = `export const pagesPaths = new Set(${JSON.stringify(
    pagesPaths
  )})`;
  const formsProperties = /* @__PURE__ */ new Map();
  for (const prop of siteData.props.values()) {
    if (prop.type === "string") {
      if (prop.name === "action" || prop.name === "method") {
        let properties = formsProperties.get(prop.instanceId);
        if (properties === void 0) {
          properties = {};
        }
        properties[prop.name] = prop.value;
        formsProperties.set(prop.instanceId, properties);
      }
    }
  }
  const generatedFormsProperties = `export const formsProperties = new Map<string, { method?: string, action?: string }>(${JSON.stringify(
    Array.from(formsProperties.entries())
  )})`;
  return `
  ${generatedPagesPaths}

  ${generatedFormsProperties}
  `;
};

// src/component-generator.ts
import { parseComponentName } from "@webstudio-is/sdk";
var generateJsxElement = ({
  scope,
  instance,
  props,
  dataSources,
  indexesWithinAncestors,
  children
}) => {
  let conditionVariableName;
  let generatedProps = "";
  generatedProps += `
${idAttribute}=${JSON.stringify(instance.id)}`;
  generatedProps += `
${componentAttribute}=${JSON.stringify(
    instance.component
  )}`;
  const index = indexesWithinAncestors.get(instance.id);
  if (index !== void 0) {
    generatedProps += `
${indexAttribute}="${index}"`;
  }
  for (const prop of props.values()) {
    if (prop.instanceId !== instance.id) {
      continue;
    }
    if (prop.name === showAttribute) {
      if (prop.type === "boolean" && prop.value === false) {
        return "";
      }
      if (prop.type === "dataSource") {
        const dataSourceId = prop.value;
        const dataSource = dataSources.get(dataSourceId);
        if (dataSource === void 0) {
          continue;
        }
        conditionVariableName = scope.getName(dataSource.id, dataSource.name);
      }
      continue;
    }
    if (prop.type === "string" || prop.type === "number" || prop.type === "boolean" || prop.type === "string[]") {
      generatedProps += `
${prop.name}={${JSON.stringify(prop.value)}}`;
      continue;
    }
    if (prop.type === "asset" || prop.type === "page") {
      continue;
    }
    if (prop.type === "dataSource") {
      const dataSourceId = prop.value;
      const dataSource = dataSources.get(dataSourceId);
      if (dataSource === void 0) {
        continue;
      }
      const dataSourceVariable = scope.getName(dataSource.id, dataSource.name);
      generatedProps += `
${prop.name}={${dataSourceVariable}}`;
      continue;
    }
    if (prop.type === "action") {
      const propVariable = scope.getName(prop.id, prop.name);
      generatedProps += `
${prop.name}={${propVariable}}`;
      continue;
    }
    prop;
  }
  let generatedElement = "";
  if (conditionVariableName) {
    generatedElement += `{${conditionVariableName} &&
`;
  }
  const [_namespace, shortName] = parseComponentName(instance.component);
  const componentVariable = scope.getName(instance.component, shortName);
  if (instance.children.length === 0) {
    generatedElement += `<${componentVariable}${generatedProps} />
`;
  } else {
    generatedElement += `<${componentVariable}${generatedProps}>
`;
    generatedElement += children;
    generatedElement += `</${componentVariable}>
`;
  }
  if (conditionVariableName) {
    generatedElement += `}
`;
  }
  return generatedElement;
};
var generateJsxChildren = ({
  scope,
  children,
  instances,
  props,
  dataSources,
  indexesWithinAncestors
}) => {
  let generatedChildren = "";
  for (const child of children) {
    if (child.type === "text") {
      generatedChildren += child.value.split("\n").map((line) => `{${JSON.stringify(line)}}
`).join(`<br />
`);
      continue;
    }
    if (child.type === "id") {
      const instanceId = child.value;
      const instance = instances.get(instanceId);
      if (instance === void 0) {
        continue;
      }
      generatedChildren += generateJsxElement({
        scope,
        instance,
        props,
        dataSources,
        indexesWithinAncestors,
        children: generateJsxChildren({
          scope,
          children: instance.children,
          instances,
          props,
          dataSources,
          indexesWithinAncestors
        })
      });
      continue;
    }
    child;
  }
  return generatedChildren;
};
var generatePageComponent = ({
  scope,
  rootInstanceId,
  instances,
  props,
  dataSources,
  indexesWithinAncestors
}) => {
  const instance = instances.get(rootInstanceId);
  if (instance === void 0) {
    return "";
  }
  const { variables, body: dataSourcesBody } = generateDataSources({
    typed: true,
    scope,
    dataSources,
    props
  });
  let generatedDataSources = "";
  for (const { valueName, setterName, initialValue } of variables.values()) {
    const initialValueString = JSON.stringify(initialValue);
    generatedDataSources += `let [${valueName}, ${setterName}] = useState<any>(${initialValueString})
`;
  }
  generatedDataSources += dataSourcesBody;
  const generatedJsx = generateJsxElement({
    scope,
    instance,
    props,
    dataSources,
    indexesWithinAncestors,
    children: generateJsxChildren({
      scope,
      children: instance.children,
      instances,
      props,
      dataSources,
      indexesWithinAncestors
    }) + "{props.scripts}\n"
  });
  let generatedComponent = "";
  generatedComponent += `const Page = (props: { scripts?: ReactNode }) => {
`;
  generatedComponent += `${generatedDataSources}`;
  generatedComponent += `return ${generatedJsx}`;
  generatedComponent += `}
`;
  return generatedComponent;
};
export {
  EmbedTemplateInstance,
  EmbedTemplateProp,
  EmbedTemplateStyleDecl,
  PropMeta,
  ReactSdkContext,
  Root,
  WsComponentMeta,
  WsEmbedTemplate,
  addGlobalRules,
  collapsedAttribute,
  componentAttribute,
  componentCategories,
  computeExpressionsDependencies,
  createElementsTree,
  createImageValueTransformer,
  decodeDataSourceVariable,
  defaultStates,
  encodeDataSourceVariable,
  generateCssText,
  generateDataFromEmbedTemplate,
  generateDataSources,
  generatePageComponent,
  generateUtilsExport,
  getClosestInstance,
  getIndexWithinAncestorFromComponentProps,
  getIndexesWithinAncestors,
  getInstanceIdFromComponentProps,
  getPresetStyleRules,
  getPropsByInstanceId,
  getStyleRules,
  idAttribute,
  indexAttribute,
  namespaceMeta,
  normalizeProps,
  renderWebstudioComponentChildren,
  selectorIdAttribute,
  showAttribute,
  stateCategories,
  validateExpression
};
